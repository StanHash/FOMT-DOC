
RULES:
	push8 A;              <=> push A:i8
	push16 A;             <=> push A:i16
	push32 A;             <=> push A:i32
	pushm A;              <=> push [A]

	push A; pop           <=> A;

	push A; push B; equ;  <=> push [A] = B;
	push A; push B; addequ; <=> push [A] += B;
	push A; push B; subequ; <=> push [A] += B;
	push A; push B; mulequ; <=> push [A] *= B;
	push A; push B; divequ; <=> push [A] /= B;
	push A; push B; modequ; <=> push [A] %= B;

	push A; push B; add;  <=> push (A + B);
	push A; push B; sub;  <=> push (A - B);
	push A; push B; mul;  <=> push (A * B);
	push A; push B; div;  <=> push (A / B);
	push A; push B; mod;  <=> push (A % B);

	push A; push B; land; <=> push (A && B);
	push A; push B; lorr; <=> push (A || B);

	push A; bne B; <=> goto B if A
	push A; beq B; <=> goto B if !A

	push A; push B; cmp; beq C; <=> goto C if (A == B)

	push A; inc           <=> push (A + 1)
	push A; dec           <=> push (A - 1)
	push A; neg           <=> push (-A)
	push A; not           <=> push (!A)

	push A; poppc;        <=> goto A

EX:
	push8 $1;
	push8 $36;
	pushm $0;
	add;
	str;
	pop;

	push 1;
	push8 $36;
	pushm $0;
	add;
	str;
	pop;

	push 1
	push 0x36
	pushm $0
	add
	str
	pop

	push 1;
	push 0x36;
	push [0];
	add;
	str;
	pop;

	push 1;
	push 0x36 + [0];
	str;
	pop;

	push [1] = 0x36 + [0];
	pop;

	[1] = 0x36 + [0];

0000 push8 $0
0002 sys $106
0007 store 
0008 pop 
0009 push8 $1
000B push8 $36
000D pushm $0
0012 add 
0013 store 
0014 pop 
0015 pushm $0
001A sys $117
001F beq $37
0024 push8 $0
0026 push8 $1
0028 pushm $0
002D sys $105
0032 b $45
0037 push8 $0
0039 push8 $2
003B pushm $0
0040 sys $105
0045 sys $1F
004A push8 $0
004C sys $22
0051 sys $21
0056 pushm $1
005B push8 $1
005D push8 $0
005F sys $11
0064 end
