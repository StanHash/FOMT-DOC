Addresses are MFOMTU

This is an object that allows managing the layout of VRAM tiles (apparently both bg and obk work? But that's hella wierd because this is a singleton). It doesn't actually do anything to the VRAM but it seems to be used exclusively for the purpose of dynamically allocating space for tiles.

TileVramManager struct layout:
    +000 | word[8] | usage bitfield for the array at +24 (in order of bits, of bytes; bit set = entry used)
    +020 | word    | pointer to next free entry in the array at +24
    +024 | some (terminated?) array of $100 entries (8 byte entries)
        initially filled by MFOMTU:080DFB44
        entry format:
            +00 | union?
                +00 | word       | (if not used) pointer to next entry (or 0 if last)
                +00 | bit[00-09] | (if used) allocation position
                    | bit[10-13] | (if used) allocation size (in powers of 2; so size 3 actually means 2^3 = 8 "slots" occupied)
                +02 | short      | (if used) used bool (?)
                +04 | short      | (if used) unique identifier (initialized from [+922] after increment)
    +824 | allocation tree
        +00 | byte | 1 if this node has some stuff allocated in it
        +01 | byte | 1 if this node is saturated (no room for more)
        +04 | object[2] (size: $7C)
            +00 | same
            +04 | object[2] (entry size: $3C)
                +00 | same
                +04 | object[2] (entry size: $1C)
                    +00 | same
                    +04 | object[2] (entry size: $0C)
                        +00 | same
                        +04 | object[2] (entry size: $04)
                            +00 | word | allocation bits

        I want to say this is used in some allocation logic.
        allocation function take as argument the "size" of allocation block (in powers of 2); and return the position of the allocated block (that position is size-aligned)

    +920 | short | number of used entries in the array at +24?
    +922 | short | same? unless this is just some always incrementing thing that's used to generate unique identifiers
    +924 | word  | number of TileVramManagerHandle alive (when reaching 0 upon destruction of one; this object also gets freed)
    +928 | short | 0?
    +92A | short | 0?

This is a single instance object; and the pointer to its sole instance is at 03000408.

TileVramManagerHandle struct layout:
    this is an empty object that only exists to abuse language constructs (allowing automatic construction/destruction of the TileVramManagerHandle singleton). smart (of course this generates some overhead but we'll eventually see if I care)

tile area identifiers: those are generated by functions and I assume they are meant to be opaque in meaning. Those are words that hold two information: bits 0-7 are for the slot index; and 8-23 are for the unique identifier (this is to avoid having invalidated idenfiers work when the slot they used to occupy got used again).

Functions:
    080078DC | TileVramManagerHandle* TileVramManagerHandle_construct(TileVramManagerHandle*);
    08007A50 | void TileVramManagerHandle_destruct(TileVramManagerHandle*, int);
    08007A90 | void TileVramManagerHandle_setAllocBounds(TileVramManagerHandle*, int start, int size);
    08007BBC | int  TileVramManagerHandle_allocate(TileVramManagerHandle*, int size);
    08007C90 | void TileVramManagerHandle_free(TileVramManagerHandle*, int id);
    08007DB4 | int  TileVramManagerHandle_getTileIndex(TileVramManagerHandle*, int id);
    08007E20 | int  TileVramManagerHandle_getSizeIdentifier(TileVramManagerHandle*, int id);

reminder that sizes are in powers of 2.
