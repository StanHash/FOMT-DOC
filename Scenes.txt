Addresses are MFOMTU

The game handles different screens and whatnot using "Scene" objects (I'm borrowing the terminology from my RPGMaker days). There's no "Scene Manager" objects or whatever tho. There's a main scene management function called by the main loop, but individual scenes can also just call up "sub"scenes and run those no problem (ex: the new game scene going through player name select scene, then farm name select scene, then dog name select scene, etc in a potential loop).

Running a scene implies a full run until it ends (not just a single frame or something like that).

Scenes are weird because there's like two kind of objects that look very similar and until recently I thought they both were the same Scene object but are actually unrelated (in terms of type inheritance).

AbstractScene struct layout:
    +00 | word | vtable (yes)

Scene (vtable: 080EE138) struct layout (this scene manages other scenes, as its run method calls doMainLoop):
    +000 | AbstractScene
    +004 | word | pointer to something (GameData?)
    +364 | byte | ?

struct Scene    { virtual ~Scene();    virtual std::auto_ptr<NotScene> run(); };
struct NotScene { virtual ~NotScene(); virtual std::auto_ptr<Scene>    run(); };

void doMainLoop(std::auto_ptr<Scene> scene)
{
    // This function generates a lot of dead code

    while (scene.get())
    {
        // constructing from a temporary object, temporary's lifetime ends, destructor called
        std::auto_ptr<NotScene> notScene(scene->run());

        // need to check and free the currently held pointer
        scene.reset();

        if (!notScene.get())
            break;

        // operator = needs to check and free the currently held pointer
        // assigning from a temporary, temporary's lifetime ends, destructor called
        scene = notScene->run();

        // notScene goes out of scope, destructor called
    }

    // scene goes out of scope, destructor called
}
